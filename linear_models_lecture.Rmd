---
title: "p8105_linear_models"
author: "Jana Lee"
date: "11/7/2019"
output: html_document
---

## Setup
```{r setup, include=FALSE}
library(tidyverse)
knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)
scale_colour_discrete = scale_colour_viridis_d
scale_fill_discrete = scale_fill_viridis_d
theme_set(theme_minimal() + theme(legend.position = "bottom"))
set.seed(1)
```


## Lecture: Linear Regression
lm = linear model, continuous outcome variable
glm = generalized linear models, binary outcome

arguments include:
- formula: y~x1 + x2
- data

Outputs are kind of a mess, but we can use the broom package to clean it up.

### Fit a model:
```{r}
library(p8105.datasets)

data("nyc_airbnb")

# Qustion: Is it possible to predict price based on a couple of preditors?
# Initial data cleaning:
nyc_airbnb = 
  nyc_airbnb %>% 
  mutate(stars = review_scores_location / 2) %>% 
  rename(
    boro = neighbourhood_group,
    neighborhood = neighbourhood) %>% 
  filter(boro != "Staten Island") %>% 
  select(price, stars, boro, neighborhood, room_type)
```

Fit the first linear model:
When you fit 4 categorical variables, it is going to organize this by alphabetical order. Bronx becomes our reference category.
Stars = if stars go up by 1-unit, airbnb increase 31.99 dollars
Boro_Brooklyn = if brooklyn goes up about 1-unit, airbnb increases 40.50 dollars
```{r}
fit = lm(price ~ stars + boro, data = nyc_airbnb)

# this is kind of helpful: summary
summary(fit)

#Another way of extracting results
summary(fit)$coef

# extract coefficients out
coef(fit)

fitted.values(fit)

#tidying results, changing the string variable to make it easier to read, and presenting this in a table
fit %>% 
  broom::tidy() %>%
  mutate(term = str_replace(term, "boro", "Boro:")) %>% 
  knitr::kable(digits = 3)

```


Looking at factors...
```{r}
# put categorical factors in order based on what is most common, which borough is more frequent?
nyc_airbnb = 
  nyc_airbnb %>% 
  mutate(
    boro = fct_infreq(boro),
    room_type = fct_infreq(room_type)
  )
```


Refitting the last model, now that factors have been reordered:
```{r}
fit = lm(price ~ stars + boro, data = nyc_airbnb)

fit %>% 
  broom::tidy()
```


Extract this information: r-squared, p-value, df, etc.
```{r}
fit %>% 
  broom::glance()
```


### Diagnostic information:
-The `modelr` package can be used to add residuals and fitted values to a dataframe. This will add in the residuals.
```{r}
modelr::add_residuals(nyc_airbnb, fit) %>% 
  ggplot(aes(x = boro, y = resid)) + 
  geom_violin() +
  ylim(-500, 500)


nyc_airbnb %>% 
  modelr::add_residuals(fit) %>% 
  ggplot(aes(x = stars, y = resid)) + geom_point()
```

What is the predicted values this model gives?
```{r}
modelr::add_predictions(nyc_airbnb, fit)
```


### Hypothesis Testing (skipping this)
```{r}
fit_null = lm(price ~ stars + boro, data = nyc_airbnb)
fit_alt = lm(price ~ stars + boro + room_type, data = nyc_airbnb)
```


### Nesting Data
We’ll now turn our attention to fitting models to datasets nested within variables – meaning, essentially, that we’ll use nest to create a list column containing datasets and fit separate models to each. This is very different from fitting nested models, even though the terminology is similar.

In the airbnb data, we might think that star ratings and room type affects price differently in each borough. One way to allow this kind of effect modification is through interaction terms:
```{r}
fit_interaction = lm(price ~ stars * boro, data = nyc_airbnb)

fit_interaction %>% 
  broom::tidy()

# This is asking: what the effect of stars for each borough on the price of airbnb? If you're looking on airbnb rentals in manhattan, this is gonna matter how much you pay. But queens and bronx, it won't really matter.

fit_interaction = lm(price ~ stars * boro + room_type*boro, data = nyc_airbnb)
# We can look at the interaction of room_type as well! This model is very flexible. Different model for the effect of stars and the effect of borough / room type.
```

```{r}
nyc_airbnb %>% 
  filter(boro == "Brooklyn") %>% 
  lm(price ~ stars + room_type, data = .) %>% 
  broom::tidy()
```


Trying mapping instead. Alternatively, we can nest within boroughs and fit borough-specific models associating price with rating and room type:
```{r}
nyc_airbnb %>% 
  nest(data = -boro) %>% 
  mutate(
    models = map(.x = data, ~lm(price ~ stars + room_type, data = .x)),
    results = map(models, broom::tidy)
  ) %>% 
  select(boro, results) %>% 
  unnest(results)
```

## Let's nest neighborhoods
```{r}
manhattan_airbnb =
  nyc_airbnb %>% 
  filter(boro == "Manhattan")

manhattan_nest_lm_res =
  manhattan_airbnb %>% 
  nest(data = -neighborhood) %>% 
  mutate(models = map(data, ~lm(price ~ stars + room_type, data = .x)),
         models = map(models, broom::tidy)) %>% 
  select(-data) %>% 
  unnest(models)
```


```{r}
manhattan_nest_lm_res %>% 
  filter(str_detect(term, "room_type")) %>% 
  ggplot(aes(x = neighborhood, y = estimate)) + 
  geom_point() + 
  facet_wrap(~term) + 
  theme(axis.text.x = element_text(angle = 80, hjust = 1))
```

Deep dive into NoHo room, where shared room is more expensive than private room:
```{r}
nyc_airbnb %>% 
  filter(neighborhood == "NoHo", room_type == "Shared room")
```


### Binary Outcomes
Using homicide datasets

Need to specify family (binomial)

```{r}

```

In Baltimore, race disparities exist. Can map across all the cities in the datasets across all cities.
